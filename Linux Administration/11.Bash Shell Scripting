		#Bash Shell Scripting
_______________________________________________________________________
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
#Bash Aliases

A bash Alias is a shortcut to a command.Every Linux distribution has at least a few aliases available.
alias - To list all aliases.
alias command - Example: alias ll='ls -alF' - runs in fast (ls -alF).So we have set ll command as shortcut to this ls command.
\command - to run the original command and not the alias.(e.g. \ls)
unalias command - to remove the alias for the current session.e.g. unalias now

!!! If you close the terminal session, the alias won't be saved.To make aliases permanent , declare them in the ~/.bash_profile or ~/.bashrc files in the user's home directory.
.bashrc is read when the shell starts. Example: This command displays the current time.alias now="date +%F\ %T".After writing this in terminal, we have to close or open another terminal , to get the .bashrc change in that.

We can use alias for ssh connection quickly - example: alias server1="ssh -p 2234 user1@12.123.12.13"

- - - - - - - - - -
SHELL SCRIPTING

A shell is a program that takes commands from the user through the keyboard , and gives them to the operating system's kernel to get executed.It's also called the command interpreter because it accepts commands from the user and then checks or interprets them to see if they are syntactically correct.And if they are , the shell will send them to the kernel for execution.The Shell gets started, when the user logs in or starts the terminal.
echo $0 - to see what shell has started.
cat /etc/passwd - to see the default shell in the last column of each user.

- - -
#Benefits of using Shell Scripts
A shell script is basically an executable text file, that contains Shell commands and other specific structures and components like variable, functions, loops and so on that are executed sequentially.Whenever you find yourself doing the same task over and over again, you should use shell scripting.This is known as repetitive task automation.
Using shell scripting , you can create your own power tools, customize administrative tasks, or create simple applications.
And since the scripts you develop are well tested, the chances of errors are highly reduced. 
Another advantage of using Shell scripts is that the one that runs them doesn't have to know all the details of Linux and programming.

Some practical examples of common tasks, where Shell scripts used are:
Monitoring the system
Data backup and restoring
Creating an email-based alert system, when something happens
User administration
Security
Auditing and many more..

- - Create a shell script
mkdir ~/Desktop/scripts
nano first_script.sh (it's common 'not necessary' for Shell scripts to have the 'sh' extension)

~/Desktop/first_script.sh file's content:
mkdir -p dir1
echo "some text" > dir1/file.txt
ls -l dir1
cat dir1/file.txt

- - Execute the script 
Normally a shell script is an executable file, so we need to add the execution permission for the owner. -> chmod 700 first_script.sh
./first_script.sh (just type the absolute or relative path of the script , and it will be executed).If you use filename without absolute or relative path it will cause an error  'command not found'.The shell is not looking for the script in the current directory.It's looking for commands and scripts only in the directories from the $PATH variable.

echo $PATH - shows the directories where the shell is looking for executables.So add the directory that contains the script to the path or execute the script using absolute or relative path.

- - - - - -
#The Shebang and comments

For executable scripts, the system expects in the first line a so-called shebang that indicates which program to run as interpreter with the script file as argument (or in simple words , what program will run the file 'bash/python/php or other').
If we execute a script without such a shebang directory , like we did in the example above, it will use the default shell of the current user.The shebang consists of a sequence of two characters: #! and then the shell file (#!/usr/bin/bash).So start the script with shebang at the first line.
So if we write e.g. a python code in script file without shebang, and execute it , it will cause a syntax error.But if we add at the first line the python3 path shebang (by knowing 'which python3'), it will execute the script.

Bash ignores everything on the line, after the # symbol.So # is used for commenting.The only exception to this rule is when the first line of the script starts with #! which is the shebang.
We can not only comment in blank line, but also after any code in any line (e.g. cat dir1/test.txt #This code read the test.txt file's content).
Bash doesn't support multiline comments.So the simplest way to write multiline comments in Bash is to add single comments one after another. 
- - - - - -
#Running Scripts

1. The most common way to run bash scripts, is to add the execution permission to the script file and run it using absolute or relative path followed by the script name, if the script is in the current directory.(examples: ./script.sh or /home/user/script.sh)

2. Another way to run a script is to write the name of the program or interpreter that will run the script and the script name like "bash script.sh" or "python3 script.sh".In this case , it is not mandatory for file to have execution permission set.This way running the script will automatically overwrite the shebang directive.

3. Last way to run a script is with 'source' command , like "source script.sh".The file does not require the execution permission and the source command reads and executes commands from the file , specified as the its argument in the current shell environment.So it is for current shell and the shebang directive won't work even if it is written at the top.The difference between the first method and this one, is that using first method './', the script will be executed in a new shell (subshell).And when using the source command, the script is running in the current shell , that's running in the terminal.Note that source and the name of the script is the same as ". script.sh".So instead of 'source script.sh' we can type '. script.sh' with dot and whitespace.
- - - - - -
#Variables in Bash

Variable is a name for a memory location where a value, which be manipulated is stored.You can create the variable in a script file or directly in the shell that's running in the terminal.
os=Linux - the name of the variable is os and it's value is "Linux".Its not applied to use whitespace before and after the equal sign.
os="Linux is OS" - use double quotes"" if the value needs to have whitespace.
Bash is weakly typed programming language that does not require you to define any date type at the time of variable declaration.So when any numeric value is assigned to a variable, then it will work as an integer.And when any text value is assigned to a variable, then it is a string.
In bash there are no any floating point numbers , only integers.  age=30
The variable names should be descriptive and remind you of the value they hold.A variable name cannot start with a number nor can it contain spaces or other special characters like .,;!? and so on.
You can use Capital letters and underscore for variable names.

echo $age | echo $os | echo $user_name  - To access the value of a variable , precede the name of the variable with a dollar sign.
echo "I'm learning $os operating system" - You can also reference the value of a variable inside the string by enclosing everything in double quotes.
(echo '$os') - This won't display the value of the variable.Instead it will display '$os' like a string, because we need to use double quotes with variables.
echo "The value of \$os is $os" - in this example, the backslash\ symbol is canceling the special meaning of the dollar sign and its printing "The value of $os is Linux".
$distro=Kali -> my_distro="I use $distro $os" -> echo my_distro ->  I use Kali Linux.So we can use variable within the variable's value.

set - To get a list of all shell variables and functions run the "set" command.So we can use "grep" to find a specific variable or function.
unset variablename - To undefine or remove a variable use the unset command -> unset os (without the $ sign, because we are not referencing the value of the variable).

Shell variables that are introduced by the operating system, shell startup scripts, or by the shell itself, are usually all in capitals.Examples: $PATH, $USER, $HOME.

declare -r logdir="logdir is a constant" - Sometimes you want to make sure that the content of a variable does not change, it's read-only.To declare such a constant use the declare built-in command with the -R option.So we can use the variable as commonly.If you try to change the value of constant/readonly variable, you'll get an error.And you can't unset/remove read-only variable (e.g. unset logdir).

Example` Print number of lines, first 5 lines, and last 7 lines of /etc/passwd which should be as a variable's value.Let's type this task in a shell script file:
#!/usr/bin/bash
filename=/etc/passwd
echo "---------------------"
echo "Number of lines in $filename"
wc -l $filename
echo "---------------------"
echo "First 5 lines"
head -n 5 $filename
echo "---------------------"
echo "Last 7 lines"
tail -n 7 $filename
echo "---------------------"

- - - - - - 
#Environment Variables

Each time we launch a terminal window in the shell inside it ,a collection of predefined variables are set with some dynamic values and are used to customize the way the system works and behaves.There are two classes of such variables: environment variables and shell variables.

Environment Variables are defined for the current shell and are inherited by any child shells or processes.They are used to pass information to processes that are spawned from the current shell.

Shell Variables are contained exclusively within the shell in which they are defined or set.

$PATH is such an environment variable that holds a list of directories, separated by columns where the shell will search for the commands you run.example: echo $PATH -> home/mrhacker/.local/bin:/usr/local/sbin.When assigning multiple values to such a variable, it's common to separate them by a colon.Most of times , you don't use environment variables directly.They are referenced by individual applications and services as needed.For example, your home directory is set as an environment variable called $HOME when you log in.The system knows your home directory by reading the value of this variable.Other environment variables will store information about the default browser or text editor, the keyboard layout settings and many more.
env - to view all environment variables set on your system.
printenv - another useful command that lists the environment variables, but also the value of a specific variable.Running it without any argument will print out all environmental variables.And giving a variable as argument will print out the value of that variable (e.g. printenv HOME PATH USER optionally).
env and printenv will print out all environment variables.

set - To display all available variables,environment, shell and those created by the user.The set command is displaying shell functions as well.And the output of information is overwhelming.To cleanup the output, we specify that set should operate in posix mode , so it won't print the shell functions.
set -o posix -> set - to run set in posix mode.So it displays only the environment and shell variables.

Environment variables can be used when you want to change the default settings of your system.For example, you want to add a directory to the path, so that you can run the scripts in that directory by typing their name.So type in ~/.bashrc:
export PATH=$PATH:~/Desktop/scripts/
After typing this , save the file and load it in the current shell source (source ~/.bashrc).So now the PATH variable contains the scripts directory , and any script or command found in that directory can be run by name as any other command , without writing ./ before its name.

To create a new environment variable, you have to export it using the "export" command before the variable name.So in a startup configuration file like .bashrc , we can add e.g. (export MYVAR=342).This is a user specific environment variable , and if you want to create a system-wide variable(available for all users), declare the variable in /etc/profile or /etc/bash.bashrc .Of course , only root can edit those files.There is also a file /etc/environment, which specifies the system-wide environment variables to be set.The file must consist of simple name=value pairs on separate lines.

- - - - - -
#Getting User Input

read - to get user input."read" will make the program flow stop until the user has given an input and has indeed the input with the return or enter key.

read variablename - The execution stopped and its waiting for the user to enter a string and hit enter.A new variable called name was created and the value stored is the string (your input).
read -p "Your text before input" variablename -  This will display a text to hint something about the input , and will store the input value into new variablename variable.

Example:
read -p "What is the IP to block? " ip
iptables -I INPUT -s $ip -j DROP
Here we will drop all packets from a specific IP address that is given by the user (we will use iptables for now).
We can type this in script file , for prompting for IP address , to block it's incoming traffic, and run the script as root.

read -s -p "your password" my_password - If you want to enter a password echoing it in the terminal, which will not show the input you type.
- - - - - -
#Special Variables and Positional Arguments

Bash scripts require argument values to provide input to the script.The arguments are the values provided after the script name when running it.For example. if you are running apt install nginx (apt is the script or the command name, install is the first argument of the script, and nginx is the second argument of the script).The name of the script and the arguments are separated by the spaces which in this case is known as the default internal field separator.There are some predefined variables for this purpose, also known as positional arguments.

Example: ./script.sh filename1 dir1 10.0.0.1
$0 is the name of the script itself (script.sh).$0 is not a positional argument , but is useful when you want to run the script again while giving it another input values.
$1 is the first positional argument (filename1)
$2 is the second positional argument (dir1)
$3 is the last positional argument (10.0.0.1).The $9 will be 9th argument, and after 9th argument , we must use arguments within ${} e.g. ${11} the eleventh.
$# is the number of the positional arguments.
$* is a string representation of all positional arguments: $1, $2, $3 ...
$? is the most recent foreground command exit status.
All of these predefined variables are available and can be used inside the scripts.
